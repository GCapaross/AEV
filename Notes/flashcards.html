<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 800px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 60px 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            cursor: pointer;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
            user-select: none;
        }

        .card:active {
            transform: scale(0.98);
        }

        .card-content {
            font-size: 24px;
            line-height: 1.6;
            text-align: center;
            width: 100%;
        }

        .question {
            color: #333;
            font-weight: 600;
        }

        .answer {
            color: #2ecc71;
            font-weight: 500;
        }

        .counter {
            margin-top: 30px;
            font-size: 16px;
            color: #666;
            text-align: center;
        }

        .hint {
            margin-top: 20px;
            font-size: 14px;
            color: #999;
            text-align: center;
        }

        .buttons {
            display: none;
            margin-top: 30px;
            gap: 20px;
        }

        .buttons.show {
            display: flex;
        }

        .btn {
            padding: 15px 40px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-wrong {
            background: #e74c3c;
            color: white;
        }

        .btn-right {
            background: #2ecc71;
            color: white;
        }

        .status {
            margin-top: 20px;
            font-size: 14px;
            color: #e67e22;
            font-weight: 600;
        }

        .toggle-stats {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #667eea;
            transition: all 0.2s;
            z-index: 1000;
        }

        .toggle-stats:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .review-now-btn {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e74c3c;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #e74c3c;
            transition: all 0.2s;
            z-index: 1000;
            display: none;
        }

        .review-now-btn.show {
            display: block;
        }

        .review-now-btn:hover {
            background: #e74c3c;
            color: white;
            transform: scale(1.05);
        }

        .stats-hidden .counter,
        .stats-hidden .status {
            display: none !important;
        }
    </style>
</head>
<body>
    <button class="toggle-stats" onclick="toggleStats()">üëÅÔ∏è Hide Stats</button>
    <button class="review-now-btn" id="reviewNowBtn" onclick="reviewNow()">üîÑ Review Wrong Now</button>

    <div class="container">
        <div class="card" id="card" onclick="flipCard()">
            <div class="card-content" id="content"></div>
            <div class="counter" id="counter"></div>
            <div class="status" id="status"></div>
            <div class="hint" id="hint">Click anywhere to reveal answer</div>
            <div class="buttons" id="buttons">
                <button class="btn btn-wrong" onclick="markWrong(event)">Got it Wrong</button>
                <button class="btn btn-right" onclick="markRight(event)">Got it Right</button>
            </div>
        </div>
    </div>

    <script>
        const flashcards = [
            {q: "What is the Heap used for in memory management?", a: "The Heap is used to store dynamically allocated variables."},
            {q: "Which functions are used for allocation and release in C and C++ regarding the Heap?", a: "Allocation uses malloc, calloc, and new (C++), while release uses free or delete (C++)."},
            {q: "What does a Heap chunk contain if it is free?", a: "A free chunk contains a Forward Pointer, a Backwards Pointer, the Previous Chunk Size (if the previous is free), and the Chunk Size plus flags."},
            {q: "What does the PREV_INUSE (0x01) flag indicate in a heap chunk?", a: "It indicates that the previous chunk is in use."},
            {q: "What defines a \"Dangling Reference\" in the context of Heap vulnerabilities?", a: "A dangling reference occurs when a pointer retains the address of a memory chunk that has already been freed, potentially giving access to memory for read and write purposes."},
            {q: "What are \"Arenas\" in the context of malloc?", a: "Arenas are regions of memory where memory is allocated from; typically, applications start with a \"Main arena,\" and new threads use other arenas to prevent interference and locking overhead."},
            {q: "What is the maximum number of arenas malloc will create?", a: "The maximum number of arenas is 8 times the number of CPUs."},
            {q: "What are \"Bins\" in Glibc?", a: "Bins are lists of recently freed chunks stored by specific sizes to allow for reuse in future allocations, improving performance."},
            {q: "What is a \"Double Free\" vulnerability?", a: "It is an attempt to free a chunk that has already been freed; bins are used to detect this, as freeing a chunk at the top of a bin is restricted."},
            {q: "What characterizes \"Unsorted bins\"?", a: "Unsorted bins store chunks rapidly without considering their size; malloc later consolidates these chunks into other bins."},
            {q: "What are \"Fastbins\"?", a: "Fastbins are a set of single linked lists of free chunks with specific sizes (up to 80 bytes), designed for fast access to recent chunks using a LIFO pattern."},
            {q: "What is \"Tcache\" (Thread Local Cache)?", a: "Tcache is a per-thread cache containing a small collection of chunks that can be accessed without locking an arena, optimizing multi-threaded application performance."},
            {q: "How does a \"Fast Bin attack\" work?", a: "It explores bins to get a pointer to an already allocated area by double-freeing a buffer (e.g., free(a), free(b), free(a)), causing the bin to have duplicated entries and returning a shadow pointer to the same memory."},
            {q: "What is 'Use After Free' and what is its impact?", a: "A vulnerability where a program continues to use a pointer after the memory it points to has been freed. This can lead to unexpected values, crashes, or code execution."},
            {q: "What is the impact of writing to a freed pointer?", a: "It can lead to unexpected values, crashes, or code execution."},
            {q: "What is ASLR?", a: "Address Space Layout Randomization (ASLR) is a countermeasure where addresses are dynamic across process execution to make predicting addresses for jumps difficult."},
            {q: "What does the command echo 2 > /proc/sys/kernel/randomize_va_space do?", a: "It enables \"Full Randomization,\" which includes the Stack, Heap, Shared Libs, and memory managed via brk()."},
            {q: "What are PIE executables?", a: "Position Independent Executables (PIE) are compiled such that their base address does not matter, fully enabling ASLR as code can be placed dynamically."},
            {q: "How can ASLR and PIE be broken?", a: "They can be broken by finding a reference to a known function, as the relative distance between addresses remains constant (e.g., knowing printf location helps find system)."},
            {q: "In a heap chunk, what does the flag IS_MMAPPED (0x02) signify?", a: "It signifies that the chunk was obtained via mmap()."},
            {q: "What happens if an allocation failure occurs in Tcache?", a: "It results in using the normal slow path, which involves locking the arena and searching for chunks."},
            {q: "What is the specific role of the \"Forward Pointer\" in a free heap chunk?", a: "It is a 4-byte pointer to the next free chunk."},
            {q: "What is the purpose of \"Largebins\"?", a: "They store large chunks derived from unsorted bins that have been coalesced; allocating from them requires finding the \"best suited\" chunk."},
            {q: "How are \"Smallbins\" stored?", a: "They are stored in an ordered manner by fixed size and are usually not contiguous."},
            {q: "In a Fastbin attack, what is the result of allocating three buffers after a double free sequence (a, b, a)?", a: "The result is receiving a legitimate pointer, another legitimate pointer, and a \"shadow pointer\" pointing to the same memory as the first."},
            {q: "What does CWE-100 target regarding Buffer Overflows?", a: "It targets improper or missing bounds checking on buffer operations, typically triggered by injected input."},
            {q: "What are the potential impacts of a Buffer Overflow?", a: "Denial of Service (program crash) or potential redirection of execution (Remote Code Execution)."},
            {q: "What is a 'Classic Buffer Overflow' and how does it occur?", a: "A vulnerability involving buffer copy without checking the size of input. It occurs when data is copied to a buffer without verifying that the destination buffer is large enough, leading to memory overwrites."},
            {q: "What is a 'Buffer Over-read' and what information can it expose?", a: "A vulnerability where software reads from a buffer and accesses memory locations beyond the buffer's boundaries. This can potentially disclose private data or sensitive information stored in adjacent memory."},
            {q: "Why are C and C++ considered \"not memory safe\"?", a: "Programmers can read/write memory freely without constraints on address or variable size, leading to access errors."},
            {q: "What does it mean that C/C++ are \"not type safe\"?", a: "Memory content can be reinterpreted (cast) arbitrarily, such as casting a buffer to an integer."},
            {q: "How does the Stack grow in memory?", a: "The Stack grows from top to bottom (from higher addresses to lower addresses)."},
            {q: "What is stored in the BSS segment?", a: "Uninitialized global variables."},
            {q: "What does a Stack Frame store?", a: "It stores Return Information, Local Variables, and Arguments to following functions."},
            {q: "What is the function of the RBP register in x64 stack management?", a: "RBP (Base Pointer) is used for frame chaining; its address is pushed to the stack when a function is called and popped when it ends to restore the caller's frame."},
            {q: "What is the function of the RIP register during a function call?", a: "RIP (Instruction Pointer) holds the address of the next instruction, which is pushed to the stack when a function is called so execution can resume at the caller later."},
            {q: "What is the difference between RBP and RIP registers in x64?", a: "RBP (Base Pointer) points to the base of the current stack frame and is used for accessing local variables and function parameters. RIP (Instruction Pointer) points to the next instruction to be executed. Both are pushed to the stack during function calls: RBP enables frame chaining to restore the caller's frame, while RIP enables returning to the correct execution point. In attacks, overwriting RIP redirects execution, while overwriting RBP can corrupt stack frame references."},
            {q: "In the context of stack vulnerabilities, what happens if sizeof(destination) is smaller than sizeof(input) during a copy?", a: "Memory is overwritten, which can affect local variables, change execution flow, or modify the stored Instruction Pointer."},
            {q: "What is a \"Buffer Over-read\" (CWE-126)?", a: "It occurs when software reads from a buffer and references memory locations after the targeted buffer, potentially disclosing private data."},
            {q: "What is \"Stack Smashing\"?", a: "It involves overwriting the stack to change the stored RBP or RIP, causing the program to jump to an arbitrary address (like a function or shellcode) upon return."},
            {q: "What is a \"Return-to-libc\" attack?", a: "An attack where the attacker jumps to relevant functions in loaded libraries (like system()) instead of injecting shellcode, often bypassing non-executable stack protections."},
            {q: "What is the \"NX bit\" or Data Executable Prevention?", a: "It is a countermeasure where stack segments are marked as Non-Executable, preventing the IP from jumping to code injected into the stack."},
            {q: "What are \"Canaries\" in stack protection?", a: "Canaries are reference values placed after local variables; the program compares this value before the function exits to detect if an overflow has occurred."},
            {q: "How do canaries detect buffer overflow attacks and what happens when they're corrupted?", a: "Canaries are placed between local variables and the return address. During a buffer overflow, an attacker must overwrite the canary to reach the return address. Before the function returns, the program checks if the canary value has changed. If it has been corrupted, the program terminates immediately, preventing the attack from hijacking control flow."},
            {q: "What does the compiler flag -fstack-protector-all do?", a: "It adds stack protection (canaries) to all functions regardless of their vulnerability."},
            {q: "What is ROP (Return Oriented Programming)?", a: "An attack technique that chains \"gadgets\" (snippets of code ending in RET) already present in the binary to execute malicious actions without injecting new code."},
            {q: "What is a \"Gadget\" in ROP?", a: "A suite of instructions ending with a branch instruction like ret (Intel) or bx lr (ARM)."},
            {q: "What is JOP (Jump Oriented Programming)?", a: "A variant of ROP that explores small gadgets ending with an indirect JMP (e.g., jmp [register]) and uses a dispatcher table."},
            {q: "What is SOP (String Oriented Programming)?", a: "An attack utilizing format string bugs (e.g., printf(str)) to read/write arbitrary values, potentially triggering ROP or JOP."},
            {q: "What is BROP (Blind Return Oriented Programming)?", a: "An attack that allows writing exploits without the target binary by crashing a service to leak gadgets and eventually constructing a remote exploit."},
            {q: "What is libc's role in memory mapping?", a: "It is a shared library loaded into memory containing standard functions like printf and system, often located between the heap and the stack."},
            {q: "What is the typical page size in memory organization?", a: "Typically 4096 bytes."},
            {q: "What is a Race Condition and when does it occur?", a: "A vulnerability involving concurrent execution using shared resources with improper synchronization. It occurs in concurrent environments where an interfering code sequence accesses a shared resource, violating exclusivity or atomicity."},
            {q: "What is a Race Condition?", a: "A condition occurring in concurrent environments where an interfering code sequence accesses a shared resource, violating exclusivity or atomicity."},
            {q: "What is a TOCTOU (Time-of-check Time-of-use) vulnerability?", a: "A race condition where software checks the state of a resource before using it, but the resource's state changes between the check and use, invalidating the original check and potentially allowing unauthorized access."},
            {q: "What characterizes a TOCTOU vulnerability?", a: "The software checks the state of a resource before using it, but the state changes between the check and use, invalidating the check."},
            {q: "What is a Covert Timing Channel and how does it work?", a: "A vulnerability where information is conveyed by modulating system behavior over time. An observer can infer protected information by measuring timing differences, such as guessing passwords based on how long comparisons take."},
            {q: "How does a Covert Timing Channel work?", a: "It conveys information by modulating system behavior over time, allowing an observer to infer protected information (e.g., guessing passwords based on comparison time)."},
            {q: "What are the ACID characteristics of database operations?", a: "Atomicity, Consistency, Isolation, and Durability."},
            {q: "What is \"Serializability\" in concurrency?", a: "It ensures that a schedule for executing concurrent transactions is equivalent to one that executes them serially."},
            {q: "What is the \"Read-Write Synchronization\" condition for Serializability?", a: "If a transaction reads a value written by another transaction in one schedule, it must do so in the equivalent serial schedule."},
            {q: "How do Locks work in DBMS?", a: "They provide the capability to lock state so only a single set of operations may be executed while others wait."},
            {q: "What is \"Versioning\" in DBMS?", a: "A mechanism where DBMS advances DB state as versions; write operations execute from the last persisted version, and concurrent operations may require a refresh."},
            {q: "Why might pthread_mutex_lock fail?", a: "It might fail if the mutex is uninitialized (EINVAL), if the priority is incorrect, or if the maximum number of recursive locks is exceeded (EAGAIN)."},
            {q: "Why is i++ considered a race condition risk in concurrent programming?", a: "It appears as a single operation but actually involves fetching from RAM, loading to register, incrementing, and storing back, which can be interrupted."},
            {q: "Give an example of a TOCTOU attack on a file system.", a: "A program checks os.access(filename) (TOC), but before open(filename) (TOU), the attacker replaces the file with a symbolic link to /etc/shadow."},
            {q: "What is a 'Race Condition in Switch' and why is it dangerous?", a: "A vulnerability where the variable being evaluated in a switch statement can change between comparisons in concurrent environments. This is dangerous because it can cause the program to match an incorrect case or no case at all, leading to unexpected behavior."},
            {q: "Why is the switch instruction dangerous regarding concurrency?", a: "The variable being switched on can change between comparisons, potentially matching an incorrect function or no function at all."},
            {q: "What is a Covert Storage Channel (CWE-515)?", a: "A path used to transfer information in a way not intended by the system designers, often relating to hidden state."},
            {q: "How can Covert Timing Channels in password validation be mitigated?", a: "By making functions time-constant or adding dominant random delays."},
            {q: "What is an example of a physical covert channel?", a: "Typing on a keyboard creates patterns due to hand anatomy, or touching a smartphone produces axis rotations."},
            {q: "What is an example of a protocol-based covert channel?", a: "Packet delays can discriminate VPN from VoIP, or packet intervals in VoIP can reveal information."},
            {q: "What is \"Atomicity\" in the context of race conditions?", a: "The property that a code sequence is behaviorally atomic, meaning no other thread can concurrently execute the same sequence against the same resource."},
            {q: "What is \"Exclusivity\" in the context of race conditions?", a: "The property that a code sequence is given exclusive access to a shared resource, preventing others from modifying it until completion."},
            {q: "What is \"Cross Site Scripting\" (XSS)?", a: "A vulnerability where an application includes unvalidated and unescaped user input as part of HTML output, allowing attackers to execute arbitrary HTML/JS in a victim's browser."},
            {q: "What is \"Reflected XSS\"?", a: "The application displays a string sent by the user (e.g., via a malicious URL) as part of the HTML output."},
            {q: "What is \"Stored XSS\"?", a: "The application stores unsanitized user input (injected by an attacker) which is later viewed and executed by another user or administrator."},
            {q: "What is \"DOM XSS\"?", a: "A vulnerability in JS frameworks or APIs where the application sends attacker-controllable data to unsafe JavaScript APIs, allowing the attacker to control remote resources."},
            {q: "What is CSRF (Cross Site Request Forgery)?", a: "An attack where the attacker subverts the client DOM or uses a crafted page to force the client browser to issue authenticated requests to an external server."},
            {q: "What is a \"Synchronizer Token\" (CSRF Token)?", a: "A hidden, random, and unique token added to forms; the server verifies this token to ensure the request is legitimate and not a CSRF attack."},
            {q: "What is the \"Cookie-to-header\" mitigation strategy?", a: "JS in the client reads a random value from a cookie and sends it in a custom header; this works because external scripts generally cannot access the cookie."},
            {q: "What does the SameSite=Strict cookie attribute do?", a: "It instructs the browser to only provide the cookie to requests originating from the same site, blocking access to external scripts."},
            {q: "What is \"Double Cookie Submission\"?", a: "A strategy using two cookies: a session cookie and a dynamic CSRF cookie; external requests fail because they lack information about the current CSRF cookie."},
            {q: "What is the \"Same Origin Policy\" (SOP)?", a: "A policy that restricts how a document or script loaded from one origin can interact with a resource from another origin."},
            {q: "How is an \"Origin\" defined in web security?", a: "By the protocol, host, and port (e.g., http://store.comp.com:80)."},
            {q: "What is \"Cross Origin Embedding\"?", a: "The ability to embed resources from other origins using tags like <script>, <img>, <video>, or <iframe>."},
            {q: "How does Cross Origin Embedding work and what are its security implications?", a: "Cross Origin Embedding allows a page to include external resources using HTML tags like <script>, <img>, <video>, or <iframe> regardless of origin. While this enables rich web experiences, it poses security risks: embedded scripts execute with the same privileges as the page, images can leak information through timing attacks, and iframes can be exploited for clickjacking. The Same Origin Policy allows embedding but restricts reading the embedded content."},
            {q: "What is CORS (Cross Origin Request Sharing)?", a: "A mechanism allowing applications to gain access to authorized data from other domains by using a relaxed Same Origin policy."},
            {q: "What is a CORS \"Preflight Request\"?", a: "A request sent by the browser to check permissions before sending the actual request, typically involving a method like OPTIONS."},
            {q: "When is a CORS Preflight NOT needed?", a: "When the request is HEAD/GET/POST via XHR, has no custom headers, and the body is text/plain."},
            {q: "What does the header Access-Control-Allow-Origin: * do?", a: "It effectively turns the content into a public resource, allowing access from any domain, which is a significant security risk."},
            {q: "What is the risk of \"Caching of Preflight responses\"?", a: "If the server changes access policies, the browser might still follow the old policy stored in the Preflight Result Cache until it expires."},
            {q: "How can an attacker exploit Access Control based on the Origin header?", a: "The attacker can spoof the Origin header (e.g., using cURL) to view sensitive information restricted to specific domains."},
            {q: "What is the impact of Stored XSS?", a: "It is severe, potentially allowing remote code execution, credential stealing, or malware delivery, often with administrator permissions."},
            {q: "What is the SameSite=Lax attribute behavior?", a: "It allows using cookies for same-site requests and top-level operations (like clicks that change location) but restricts others."},
            {q: "What are the three categories of interactions between origins in SOP?", a: "Cross origin writes, Cross origin embedding, and Cross origin reads (not allowed without CORS)."},
            {q: "Why is \"Universal Allow\" (*) in CORS dangerous for intranet sites?", a: "An attacker can steal data from an intranet site by enticing a user to visit an external attacker-controlled site."},
            {q: "What is the relationship between malloc and threads regarding arenas?", a: "New threads use different arenas to avoid mutex lock costs; if too many arenas exist, malloc reuses existing ones."},
            {q: "What happens to data when a heap chunk is allocated?", a: "The call reserves a chunk and returns a pointer to the buffer (payload)."},
            {q: "What constitutes the metadata of an In-use Chunk?", a: "prev_size, size, and flags (AMP: Allocated Arena, Mmap'd, Prev in use)."}
        ];

        let deck = [];
        let wrongAnswers = [];
        let currentIndex = 0;
        let showingAnswer = false;
        let totalSeen = 0;
        let isReviewMode = false;
        let statsHidden = false;
        let immediateReview = false;

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function startNewRound() {
            deck = shuffle(flashcards);
            wrongAnswers = [];
            currentIndex = 0;
            isReviewMode = false;
        }

        function startReviewMode() {
            deck = shuffle(wrongAnswers);
            wrongAnswers = [];
            currentIndex = 0;
            isReviewMode = true;
        }

        function updateStatus() {
            const status = document.getElementById('status');
            const reviewBtn = document.getElementById('reviewNowBtn');

            if (isReviewMode) {
                status.textContent = 'üîÑ REVIEW MODE: Get these right!';
                status.style.display = 'block';
                reviewBtn.classList.remove('show');
            } else {
                status.style.display = 'none';
                if (wrongAnswers.length > 0) {
                    reviewBtn.classList.add('show');
                } else {
                    reviewBtn.classList.remove('show');
                }
            }
        }

        function showCard() {
            const card = deck[currentIndex];
            const content = document.getElementById('content');
            const counter = document.getElementById('counter');
            const hint = document.getElementById('hint');
            const buttons = document.getElementById('buttons');

            if (showingAnswer) {
                content.innerHTML = `<div class="answer">${card.a}</div>`;
                hint.textContent = 'Choose whether you got it right or wrong';
                buttons.classList.add('show');
            } else {
                content.innerHTML = `<div class="question">${card.q}</div>`;
                hint.textContent = 'Click anywhere to reveal answer';
                buttons.classList.remove('show');
            }

            const mode = isReviewMode ? ' (Review)' : '';
            const wrongCount = wrongAnswers.length > 0 ? ` | Wrong: ${wrongAnswers.length}` : '';
            counter.textContent = `Card ${currentIndex + 1} of ${deck.length}${mode} | Total reviewed: ${totalSeen}${wrongCount}`;

            updateStatus();
        }

        function flipCard() {
            if (!showingAnswer) {
                showingAnswer = true;
                showCard();
            }
        }

        function nextCard() {
            showingAnswer = false;
            currentIndex++;
            totalSeen++;

            if (currentIndex >= deck.length) {
                // Finished current deck
                if (wrongAnswers.length > 0) {
                    // Start review mode with wrong answers
                    startReviewMode();
                } else if (isReviewMode && immediateReview) {
                    // Finished immediate review with no new wrong answers, restart everything
                    immediateReview = false;
                    totalSeen = 0;
                    startNewRound();
                } else if (isReviewMode) {
                    // Finished review with no new wrong answers, start new round
                    startNewRound();
                } else {
                    // Finished first pass, check if there are wrong answers
                    if (wrongAnswers.length > 0) {
                        startReviewMode();
                    } else {
                        startNewRound();
                    }
                }
            }

            showCard();
        }

        function markWrong(event) {
            event.stopPropagation();
            wrongAnswers.push(deck[currentIndex]);
            nextCard();
        }

        function markRight(event) {
            event.stopPropagation();
            // Don't add to wrong answers, just move to next
            nextCard();
        }

        function toggleStats() {
            statsHidden = !statsHidden;
            const card = document.getElementById('card');
            const toggleBtn = document.querySelector('.toggle-stats');

            if (statsHidden) {
                card.classList.add('stats-hidden');
                toggleBtn.textContent = 'üëÅÔ∏è Show Stats';
            } else {
                card.classList.remove('stats-hidden');
                toggleBtn.textContent = 'üëÅÔ∏è Hide Stats';
            }
        }

        function reviewNow() {
            if (wrongAnswers.length > 0) {
                immediateReview = true;
                startReviewMode();
                showCard();
            }
        }

        // Initialize
        startNewRound();
        showCard();
    </script>
</body>
</html>